var ge = Object.defineProperty;
var Ce = (i, e, o) => e in i ? ge(i, e, { enumerable: !0, configurable: !0, writable: !0, value: o }) : i[e] = o;
var $ = (i, e, o) => (Ce(i, typeof e != "symbol" ? e + "" : e, o), o);
import T, { createContext as ve, useContext as Pe, useRef as S, useEffect as L, useState as ye, useCallback as x, useLayoutEffect as Se, useImperativeHandle as we, forwardRef as pe, useMemo as Ee } from "react";
import { ScreenSpaceEventType as d, ScreenSpaceEventHandler as fe, Event as re, BillboardCollection as be, BillboardGraphics as De, BoxGraphics as $e, Cesium3DTileset as Me, Cesium3DTilesetGraphics as Re, CesiumWidget as Ge, ClassificationPrimitive as Te, CloudCollection as ke, CorridorGraphics as Le, CustomDataSource as Be, CylinderGraphics as Oe, CzmlDataSource as Ae, EllipseGraphics as Fe, EllipsoidGraphics as Ie, Entity as Ve, Fog as ae, GeoJsonDataSource as _e, GroundPolylinePrimitive as Ue, GroundPrimitive as We, ImageryLayer as He, KmlDataSource as ze, LabelCollection as Ne, LabelGraphics as Ke, Model as je, ModelGraphics as qe, Moon as ce, ParticleSystem as Je, PathGraphics as Ze, PlaneGraphics as Qe, PointGraphics as xe, PointPrimitiveCollection as Xe, PolygonGraphics as Ye, PolylineCollection as ei, PolylineGraphics as ii, PolylineVolumeGraphics as oi, PostProcessStage as ti, PostProcessStageLibrary as M, PostProcessStageComposite as ni, Primitive as si, RectangleGraphics as ri, SceneMode as X, Sun as le, TimeDynamicPointCloud as ai, Viewer as ci, WallGraphics as li } from "cesium";
import { createPortal as di } from "react-dom";
const ie = ve({}), { Provider: Nn, Consumer: ui } = ie, z = () => Pe(ie) || {}, N = (i, e) => {
  const o = (t) => {
    const n = z(), r = S(), u = S(!1);
    return L(() => () => {
      n.camera && t.cancelFlightOnUnmount && n.camera.cancelFlight();
    }, [n.camera, t.cancelFlightOnUnmount]), L(() => {
      n.camera && n.scene && !n.scene.isDestroyed() && (!t.once || !u.current) && (n.camera.cancelFlight(), e(n.camera, t, r.current), u.current = !0), r.current = t;
    }), null;
  };
  return o.displayName = i, o;
};
function mi(i, e) {
  return e ? Y(i).reduce((o, [t, n]) => (U(e, t) && (o[t] = n), o), {}) : {};
}
function Y(i) {
  return Object.keys(i).map((e) => [e, i[e]]);
}
function U(i, e) {
  return !!i && i.indexOf(e) !== -1;
}
function hi(i, e) {
  return !!i && !!e && [...Object.keys(i), ...Object.keys(e)].every((o) => i[o] === e[o]);
}
function yi(i) {
  return i && typeof i.isDestroyed == "function" && typeof i.destroy == "function";
}
function pi(i) {
  return yi(i) && i.isDestroyed();
}
const k = "__RESIUM_EVENT_MANAGER", ee = [
  "onClick",
  "onDoubleClick",
  "onMouseDown",
  "onMouseUp",
  "onMiddleClick",
  "onMiddleDown",
  "onMiddleUp",
  "onMouseMove",
  "onPinchEnd",
  "onPinchMove",
  "onPinchStart",
  "onRightClick",
  "onRightDown",
  "onRightUp",
  "onWheel",
  "onMouseEnter",
  "onMouseLeave"
], oe = class {
  constructor(e) {
    $(this, "scene");
    $(this, "sshe");
    $(this, "events", {
      onClick: /* @__PURE__ */ new Map(),
      onDoubleClick: /* @__PURE__ */ new Map(),
      onMouseDown: /* @__PURE__ */ new Map(),
      onMouseUp: /* @__PURE__ */ new Map(),
      onMiddleClick: /* @__PURE__ */ new Map(),
      onMiddleDown: /* @__PURE__ */ new Map(),
      onMiddleUp: /* @__PURE__ */ new Map(),
      onMouseMove: /* @__PURE__ */ new Map(),
      onPinchEnd: /* @__PURE__ */ new Map(),
      onPinchMove: /* @__PURE__ */ new Map(),
      onPinchStart: /* @__PURE__ */ new Map(),
      onRightClick: /* @__PURE__ */ new Map(),
      onRightDown: /* @__PURE__ */ new Map(),
      onRightUp: /* @__PURE__ */ new Map(),
      onWheel: /* @__PURE__ */ new Map(),
      onMouseEnter: /* @__PURE__ */ new Map(),
      onMouseLeave: /* @__PURE__ */ new Map()
    });
    $(this, "hovered");
    $(this, "onMouseMove", (e) => {
      var t, n, r, u, h, c;
      const o = this.pick(e.endPosition);
      this.hovered !== o && (this.hovered && ((t = this.getEventCallback("onMouseLeave", this.hovered)) == null || t(e, this.hovered), (n = this.getEventCallback("onMouseLeave", null)) == null || n(e, this.hovered)), o && ((r = this.getEventCallback("onMouseEnter", o)) == null || r(e, o), (u = this.getEventCallback("onMouseEnter", null)) == null || u(e, o))), o && ((h = this.getEventCallback("onMouseMove", o)) == null || h(e, o)), (c = this.getEventCallback("onMouseMove", null)) == null || c(e, o), this.hovered = o;
    });
    $(this, "eventCallback", (e) => (o) => {
      var n, r;
      const t = this.pick(o == null ? void 0 : o.position);
      t && ((n = this.getEventCallback(e, t)) == null || n(o, t)), (r = this.getEventCallback(e, null)) == null || r(o, t);
    });
    this.scene = e, this.sshe = new fe(e == null ? void 0 : e.canvas);
  }
  destroy() {
    this.hovered = void 0, this.sshe.isDestroyed() || this.sshe.destroy();
  }
  isDestroyed() {
    return this.sshe.isDestroyed();
  }
  on(e, o, t) {
    e && o === "onWheel" || this.events[o].set(e, t);
  }
  off(e, o) {
    this.events[o].delete(e), this.hovered === e && (this.hovered = void 0);
  }
  setEvents(e, o) {
    Y(o).forEach(([t, n]) => {
      const r = t;
      U(ee, r) && (n ? this.on(e, r, n) : this.off(e, r));
    }), this.commit();
  }
  clearEvents(e) {
    this.hovered = void 0, ee.forEach((o) => {
      this.off(e, o);
    }), this.commit();
  }
  commit() {
    const e = this.sshe, o = this.sshe.isDestroyed();
    o || (this.events.onMouseEnter.size === 0 && this.events.onMouseLeave.size === 0 && this.events.onMouseMove.size === 0 ? this.sshe.removeInputAction(d.MOUSE_MOVE) : this.sshe.getInputAction(d.MOUSE_MOVE) || this.sshe.setInputAction(this.onMouseMove, d.MOUSE_MOVE)), Y(this.events).forEach(([t, n]) => {
      if (t === "onMouseEnter" || t === "onMouseLeave" || t === "onMouseMove")
        return;
      const r = oe.eventTypeMap[t];
      o || (n.size === 0 ? e.removeInputAction(r) : e.getInputAction(r) || e.setInputAction(this.eventCallback(t), r));
    });
  }
  getScreenSpaceEventHandler() {
    return this.sshe;
  }
  getEventCallback(e, o) {
    var t, n;
    return o === null ? this.events[e].get(null) : this.events[e].get(o.id) || this.events[e].get((n = (t = o.id) == null ? void 0 : t.entityCollection) == null ? void 0 : n.owner) || this.events[e].get(o.primitive) || this.events[e].get(o.tileset);
  }
  pick(e) {
    var o;
    if (!!e)
      return (o = this.scene) == null ? void 0 : o.pick(e);
  }
};
let _ = oe;
$(_, "eventTypeMap", {
  onClick: d.LEFT_CLICK,
  onDoubleClick: d.LEFT_DOUBLE_CLICK,
  onMouseDown: d.LEFT_DOWN,
  onMouseUp: d.LEFT_UP,
  onMiddleClick: d.MIDDLE_CLICK,
  onMiddleDown: d.MIDDLE_DOWN,
  onMiddleUp: d.MIDDLE_UP,
  onMouseMove: d.MOUSE_MOVE,
  onPinchEnd: d.PINCH_END,
  onPinchMove: d.PINCH_MOVE,
  onPinchStart: d.PINCH_START,
  onRightClick: d.RIGHT_CLICK,
  onRightDown: d.RIGHT_DOWN,
  onRightUp: d.RIGHT_UP,
  onWheel: d.WHEEL,
  onMouseEnter: d.MOUSE_MOVE,
  onMouseLeave: d.MOUSE_MOVE
});
const fi = ({
  name: i,
  create: e,
  destroy: o,
  provide: t,
  update: n,
  cesiumReadonlyProps: r,
  cesiumEventProps: u,
  otherProps: h,
  setCesiumPropsAfterCreate: c,
  useCommonEvent: y,
  useRootEvent: f
}, g, w) => {
  const a = S(), p = z(), G = S(t ? {} : void 0), B = S({}), E = S(g), b = S({}), [K, te] = ye(!1), W = S(!1), j = S(null), H = S(), q = p == null ? void 0 : p[k], J = x(
    (l) => {
      var F;
      if (!a.current)
        return;
      const v = a.current, D = Object.keys(l), O = Object.keys(u || []), R = D.concat(
        Object.keys(b.current).filter((m) => !D.includes(m))
      ).filter((m) => b.current[m] !== l[m]).map((m) => [m, b.current[m], l[m]]), C = [];
      for (const [m, Z, I] of R)
        if (r != null && r.includes(m))
          C.push(m);
        else if (U(O, m)) {
          const Q = u == null ? void 0 : u[m], V = v[Q];
          V instanceof re && (typeof Z > "u" ? (V.addEventListener(I), B.current[Q] = I) : typeof I > "u" ? (V.removeEventListener(Z), delete B.current[Q]) : (V.removeEventListener(Z), V.addEventListener(I)));
        } else
          m !== "children" && !ee.includes(m) && !(h != null && h.includes(m)) && (v[m] = I);
      const A = f ? (F = G.current) == null ? void 0 : F[k] : q;
      y && A && a.current && A.setEvents(f ? null : a.current, l), n && W.current && n(a.current, l, b.current, p), b.current = l, E.current = l, W.current && C.length > 0 && (process.env.NODE_ENV !== "production" && console.warn(
        `Warning: <${i}> is recreated because following read-only props have been updated: ${C.join(
          ", "
        )}`
      ), se(), ne());
    },
    []
  ), ne = x(() => {
    var D;
    const l = e == null ? void 0 : e(p, E.current, j.current);
    if (Array.isArray(l) ? (a.current = l[0], H.current = l[1]) : a.current = l, c)
      J(E.current);
    else {
      if (a.current && u) {
        const O = a.current;
        for (const R of Object.keys(E.current)) {
          const C = u[R];
          if (C) {
            const A = E.current[R], F = O[C];
            A && F instanceof re && F.addEventListener(A);
          }
        }
      }
      b.current = E.current;
    }
    t && a.current && (G.current = { ...p, ...t(a.current, p, g, H.current) });
    const v = f ? (D = G.current) == null ? void 0 : D[k] : q;
    y && v && a.current && v.setEvents(f ? null : a.current, E.current);
  }, []), se = x(() => {
    var v, D;
    a.current && o && o(a.current, p, j.current, H.current);
    const l = f ? (v = G.current) == null ? void 0 : v[k] : q;
    if (y && l && a.current && l.clearEvents(f ? null : a.current), a.current && !pi(a.current)) {
      const O = Object.keys(B.current);
      for (const R of O) {
        const C = a.current[R];
        (D = C == null ? void 0 : C.removeEventListener) == null || D.call(C, B.current[R]);
      }
    }
    B.current = {}, G.current = void 0, H.current = void 0, a.current = void 0, te(!1), W.current = !1;
  }, []);
  return Se(() => (ne(), () => se()), []), L(() => {
    var l, v;
    K ? hi(g, b.current) || (J(g), (v = (l = p.__$internal) == null ? void 0 : l.onUpdate) == null || v.call(l)) : (b.current = g, E.current = g, te(!0), W.current = !0);
  }, [p.__$internal, K, g, J]), we(w, () => ({
    cesiumElement: a.current
  })), [G.current, K, j];
}, s = ({
  renderContainer: i,
  noChildren: e,
  containerProps: o,
  defaultProps: t,
  ...n
}) => {
  const r = (u, h) => {
    const c = {
      ...t,
      ...u
    }, [y, f, g] = fi(
      n,
      c,
      h
    );
    if (e)
      return null;
    const w = f && "children" in c ? c.children : null, a = i ? /* @__PURE__ */ T.createElement(
      "div",
      {
        "data-testid": "resium-container",
        ref: g,
        ...typeof o == "function" ? o(c) : mi(c, o)
      },
      w
    ) : w ? /* @__PURE__ */ T.createElement(T.Fragment, null, w) : null;
    return y ? /* @__PURE__ */ T.createElement(ie.Provider, { value: y }, a) : a;
  };
  return r.displayName = n.name, pe(r);
}, gi = ["enabled", "selected"], P = (i) => s({
  name: i.name,
  create(e, o) {
    if (!e.scene)
      return;
    const t = i.create(o, e.scene.postProcessStages);
    return typeof o.enabled == "boolean" && (t.enabled = o.enabled), o.selected && "selected" in t && (t.selected = o.selected), i.props.forEach((n) => {
      !U(i.readonlyProps, n) && typeof o[n] < "u" && (t.uniforms[n] = o[n]);
    }), !i.noMount && e.scene && !e.scene.isDestroyed() && e.scene.postProcessStages.add(t), t;
  },
  destroy(e, o) {
    i.noMount ? e.enabled = !1 : (o.scene && !o.scene.isDestroyed() && o.scene.postProcessStages.remove(e), e.isDestroyed() || e.destroy());
  },
  update(e, o, t) {
    i.props.forEach((n) => {
      !U(i.readonlyProps, n) && o[n] !== t[n] && (e.uniforms[n] = o[n]);
    });
  },
  cesiumProps: gi,
  cesiumReadonlyProps: i.readonlyProps,
  defaultProps: {
    enabled: !0
  }
}), Kn = (i) => pe((e, o) => /* @__PURE__ */ T.createElement(ui, null, (t) => /* @__PURE__ */ T.createElement(i, { ...e, ref: o, cesium: t }))), Ci = [
  "alignedAxis",
  "color",
  "disableDepthTestDistance",
  "distanceDisplayCondition",
  "eyeOffset",
  "height",
  "heightReference",
  "horizontalOrigin",
  "image",
  "pixelOffset",
  "pixelOffsetScaleByDistance",
  "position",
  "rotation",
  "scale",
  "scaleByDistance",
  "show",
  "sizeInMeters",
  "translucencyByDistance",
  "verticalOrigin",
  "width"
], vi = s({
  name: "Billboard",
  create(i, e) {
    var o;
    return (o = i.billboardCollection) == null ? void 0 : o.add(e);
  },
  destroy(i, e) {
    e.billboardCollection && !e.billboardCollection.isDestroyed() && e.billboardCollection.remove(i);
  },
  cesiumProps: Ci,
  useCommonEvent: !0
}), jn = vi, Pi = [
  "blendOption",
  "debugShowBoundingVolume",
  "debugShowTextureAtlas",
  "modelMatrix",
  "show"
], Si = s({
  name: "BillboardCollection",
  create(i, e) {
    if (!i.primitiveCollection)
      return;
    const o = new be({
      modelMatrix: e.modelMatrix,
      debugShowBoundingVolume: e.debugShowBoundingVolume,
      scene: i.scene,
      blendOption: e.blendOption
    });
    return i.primitiveCollection.add(o), o;
  },
  destroy(i, e) {
    e.primitiveCollection && !e.primitiveCollection.isDestroyed() && e.primitiveCollection.remove(i), i.isDestroyed() || i.destroy();
  },
  provide(i) {
    return {
      billboardCollection: i
    };
  },
  cesiumProps: Pi
}), qn = Si, wi = [
  "image",
  "show",
  "scale",
  "horizontalOrigin",
  "verticalOrigin",
  "eyeOffset",
  "pixelOffset",
  "rotation",
  "alignedAxis",
  "width",
  "height",
  "color",
  "scaleByDistance",
  "translucencyByDistance",
  "pixelOffsetScaleByDistance",
  "imageSubRegion",
  "sizeInMeters",
  "heightReference",
  "distanceDisplayCondition",
  "disableDepthTestDistance"
], Ei = {
  onDefinitionChange: "definitionChanged"
}, bi = s({
  name: "BillboardGraphics",
  create(i, e) {
    if (!i.entity)
      return;
    const o = new De(e);
    return i.entity.billboard = o, o;
  },
  destroy(i, e) {
    e.entity && (e.entity.billboard = void 0);
  },
  cesiumProps: wi,
  cesiumEventProps: Ei
}), Jn = bi, Di = [
  "heightReference",
  "dimensions",
  "show",
  "fill",
  "material",
  "outline",
  "outlineColor",
  "outlineWidth",
  "shadows",
  "distanceDisplayCondition"
], $i = {
  onDefinitionChange: "definitionChanged"
}, Mi = s({
  name: "BoxGraphics",
  create(i, e) {
    if (!i.entity)
      return;
    const o = new $e(e);
    return i.entity.box = o, o;
  },
  destroy(i, e) {
    e.entity && (e.entity.box = void 0);
  },
  cesiumProps: Di,
  cesiumEventProps: $i
}), Zn = Mi, Ri = [
  "position",
  "direction",
  "up",
  "right",
  "frustum",
  "defaultMoveAmount",
  "defaultLookAmount",
  "defaultRotateAmount",
  "defaultZoomAmount",
  "constrainedAxis",
  "maximumZoomFactor",
  "percentageChanged"
], Gi = {
  onChange: "changed",
  onMoveEnd: "moveEnd",
  onMoveStart: "moveStart"
}, Ti = s({
  name: "Camera",
  create: (i) => {
    var e;
    return (e = i.scene) == null ? void 0 : e.camera;
  },
  cesiumProps: Ri,
  cesiumEventProps: Gi,
  setCesiumPropsAfterCreate: !0
}), Qn = Ti, ki = N(
  "CameraFlyHome",
  (i, { duration: e }) => {
    i.flyHome(e);
  }
), xn = ki, Li = N(
  "CameraFlyTo",
  (i, { onComplete: e, onCancel: o, ...t }) => {
    i.flyTo({ ...t, complete: e, cancel: o });
  }
), Xn = Li, Bi = N(
  "CameraLookAt",
  (i, { target: e, offset: o }) => {
    i.lookAt(e, o);
  }
), Yn = Bi, Oi = N(
  "CameraFlyToBoundingSphere",
  (i, { boundingSphere: e, onComplete: o, onCancel: t, ...n }) => {
    i.flyToBoundingSphere(e, {
      ...n,
      complete: o,
      cancel: t
    });
  }
), es = Oi, Ai = [
  "show",
  "modelMatrix",
  "shadows",
  "maximumScreenSpaceError",
  "maximumMemoryUsage",
  "cullRequestsWhileMoving",
  "cullRequestsWhileMovingMultiplier",
  "preloadWhenHidden",
  "preloadFlightDestinations",
  "preferLeaves",
  "progressiveResolutionHeightFraction",
  "foveatedScreenSpaceError",
  "foveatedConeSize",
  "foveatedMinimumScreenSpaceErrorRelaxation",
  "foveatedInterpolationCallback",
  "foveatedTimeDelay",
  "dynamicScreenSpaceError",
  "dynamicScreenSpaceErrorDensity",
  "dynamicScreenSpaceErrorFactor",
  "dynamicScreenSpaceErrorHeightFalloff",
  "skipLevelOfDetail",
  "baseScreenSpaceError",
  "skipScreenSpaceErrorFactor",
  "skipLevels",
  "immediatelyLoadDesiredLevelOfDetail",
  "loadSiblings",
  "clippingPlanes",
  "classificationType",
  "ellipsoid",
  "lightColor",
  "colorBlendAmount",
  "colorBlendMode",
  "debugFreezeFrame",
  "debugColorizeTiles",
  "debugWireframe",
  "debugShowBoundingVolume",
  "debugShowContentBoundingVolume",
  "debugShowViewerRequestVolume",
  "debugShowGeometricError",
  "debugShowRenderingStatistics",
  "debugShowMemoryUsage",
  "debugShowUrl",
  "style",
  "backFaceCulling",
  "vectorClassificationOnly",
  "vectorKeepDecodedPositions",
  "splitDirection",
  "customShader",
  "imageBasedLighting",
  "showCreditsOnScreen",
  "featureIdLabel",
  "instanceFeatureIdLabel",
  "imageBasedLighting",
  "outlineColor"
], Fi = [
  "url",
  "showOutline",
  "cullWithChildrenBounds",
  "debugHeatmapTilePropertyName",
  "enableDebugWireframe",
  "modelUpAxis",
  "modelForwardAxis",
  "projectTo2D",
  "enableShowOutline"
], Ii = {
  onAllTilesLoad: "allTilesLoaded",
  onInitialTilesLoad: "initialTilesLoaded",
  onLoadProgress: "loadProgress",
  onTileFailed: "tileFailed",
  onTileLoad: "tileLoad",
  onTileUnload: "tileUnload",
  onTileVisible: "tileVisible"
}, Vi = ["onReady"], _i = s({
  name: "Cesium3DTileset",
  create(i, e) {
    if (!i.primitiveCollection)
      return;
    const o = new Me(e);
    return e.colorBlendAmount && (o.colorBlendAmount = e.colorBlendAmount), e.colorBlendMode && (o.colorBlendMode = e.colorBlendMode), e.style && (o.style = e.style), e.onReady && o.readyPromise.then(e.onReady), i.primitiveCollection.add(o), o;
  },
  destroy(i, e) {
    e.primitiveCollection && !e.primitiveCollection.isDestroyed() && e.primitiveCollection.remove(i), i.isDestroyed() || i.destroy();
  },
  cesiumProps: Ai,
  cesiumReadonlyProps: Fi,
  cesiumEventProps: Ii,
  otherProps: Vi,
  useCommonEvent: !0
}), is = _i, Ui = ["show", "uri", "maximumScreenSpaceError"], Wi = {
  onDefinitionChange: "definitionChanged"
}, Hi = s({
  name: "Cesium3DTilesetGraphics",
  create(i, e) {
    if (!i.entity)
      return;
    const o = new Re(e);
    return i.entity.tileset = o, o;
  },
  destroy(i, e) {
    e.entity && (e.entity.tileset = void 0);
  },
  cesiumProps: Ui,
  cesiumEventProps: Wi
}), os = Hi, zi = [
  "resolutionScale",
  "useDefaultRenderLoop",
  "targetFrameRate",
  "useBrowserRecommendedResolution"
], Ni = [
  "clock",
  "imageryProvider",
  "terrainProvider",
  "skyBox",
  "skyAtmosphere",
  "sceneMode",
  "scene3DOnly",
  "orderIndependentTranslucency",
  "mapMode2D",
  "mapProjection",
  "globe",
  "showRenderLoopErrors",
  "contextOptions",
  "creditContainer",
  "creditViewport",
  "shadows",
  "terrainShadows",
  "requestRenderMode",
  "maximumRenderTimeChange",
  "msaaSamples",
  "blurActiveElementOnCanvasFocus"
], Ki = ["className", "id", "style", "full", "containerProps"], ji = s({
  name: "CesiumWidget",
  create(i, e, o) {
    if (!o)
      return;
    const t = new Ge(o, e);
    if (!t)
      return;
    typeof e.resolutionScale == "number" && (t.resolutionScale = e.resolutionScale);
    const n = new _(t.scene);
    return [t, n];
  },
  destroy(i, e, o, t) {
    t && !t.isDestroyed() && t.destroy(), i.isDestroyed() || i.destroy();
  },
  provide(i, e, o, t) {
    return {
      cesiumWidget: i,
      scene: i.scene,
      camera: i.scene.camera,
      imageryLayerCollection: i.scene.globe.imageryLayers,
      primitiveCollection: i.scene.primitives,
      globe: i.scene.globe,
      __$internal: {
        onUpdate: o == null ? void 0 : o.onUpdate
      },
      [k]: t
    };
  },
  containerProps: ({ id: i, className: e, style: o, full: t, containerProps: n }) => ({
    className: e,
    id: i,
    style: {
      ...t ? {
        position: "absolute",
        bottom: "0",
        left: "0",
        right: "0",
        top: "0"
      } : {},
      ...o
    },
    ...n
  }),
  cesiumProps: zi,
  cesiumReadonlyProps: Ni,
  otherProps: Ki,
  renderContainer: !0,
  useCommonEvent: !0,
  useRootEvent: !0
}), ts = ji, qi = [
  "classificationType",
  "debugShowBoundingVolume",
  "debugShowShadowVolume",
  "show"
], Ji = [
  "allowPicking",
  "asynchronous",
  "compressVertices",
  "geometryInstances",
  "interleave",
  "releaseGeometryInstances",
  "vertexCacheOptimize",
  "appearance"
], Zi = ["onReady"], Qi = s({
  name: "ClassificationPrimitive",
  create(i, e) {
    if (!i.primitiveCollection)
      return;
    const o = new Te(e);
    return e.onReady && o.readyPromise.then(e.onReady), i.primitiveCollection.add(o), o;
  },
  destroy(i, e) {
    e.primitiveCollection && !e.primitiveCollection.isDestroyed() && e.primitiveCollection.remove(i), i.isDestroyed() || i.destroy();
  },
  cesiumProps: qi,
  cesiumReadonlyProps: Ji,
  otherProps: Zi,
  useCommonEvent: !0
}), ns = Qi, xi = {
  onStop: "onStop",
  onTick: "onTick"
}, Xi = [
  "canAnimate",
  "clockRange",
  "clockStep",
  "currentTime",
  "multiplier",
  "shouldAnimate",
  "startTime",
  "stopTime"
], Yi = s({
  name: "Clock",
  create: (i) => {
    var e;
    return (e = i.cesiumWidget) == null ? void 0 : e.clock;
  },
  cesiumProps: Xi,
  cesiumEventProps: xi,
  setCesiumPropsAfterCreate: !0
}), ss = Yi, eo = [
  "noiseDetail",
  "noiseOffset",
  "show",
  "debugBillboards",
  "debugEllipsoids"
], io = s({
  name: "CloudCollection",
  create: (i) => {
    if (!i.primitiveCollection)
      return;
    const e = new ke();
    return i.primitiveCollection.add(e), e;
  },
  destroy(i, e) {
    e.primitiveCollection && !e.primitiveCollection.isDestroyed() && e.primitiveCollection.remove(i), i.isDestroyed() || i.destroy();
  },
  provide: (i) => ({
    cloudCollection: i
  }),
  cesiumProps: eo,
  setCesiumPropsAfterCreate: !0
}), rs = io, oo = [
  "positions",
  "width",
  "cornerType",
  "height",
  "heightReference",
  "extrudedHeight",
  "extrudedHeightReference",
  "show",
  "fill",
  "material",
  "outline",
  "outlineColor",
  "outlineWidth",
  "granularity",
  "shadows",
  "distanceDisplayCondition",
  "zIndex",
  "classificationType"
], to = {
  onDefinitionChange: "definitionChanged"
}, no = s({
  name: "CorridorGraphics",
  create(i, e) {
    if (!i.entity)
      return;
    const o = new Le(e);
    return e.classificationType && (o.classificationType = e.classificationType), i.entity.corridor = o, o;
  },
  destroy(i, e) {
    e.entity && (e.entity.corridor = void 0);
  },
  cesiumProps: oo,
  cesiumEventProps: to
}), as = no, so = [
  "show",
  "position",
  "scale",
  "maximumSize",
  "slice",
  "brightness",
  "color"
], ro = s({
  name: "CumulusCloud",
  create: (i, e) => {
    var o;
    return (o = i.cloudCollection) == null ? void 0 : o.add(e);
  },
  destroy(i, e) {
    e.cloudCollection && !e.cloudCollection.isDestroyed() && e.cloudCollection.remove(i);
  },
  cesiumProps: so
}), cs = ro, ao = ["clustering", "name", "show", "clock", "isLoading"], co = {
  onChange: "changedEvent",
  onError: "errorEvent",
  onLoading: "loadingEvent"
}, lo = s({
  name: "CustomDataSource",
  create(i, e) {
    if (!i.dataSourceCollection)
      return;
    const o = new Be(e.name);
    return e.clustering && (o.clustering = e.clustering), typeof e.show == "boolean" && (o.show = e.show), typeof e.clock < "u" && (o.clock = e.clock), i.dataSourceCollection.add(o), o;
  },
  destroy(i, e) {
    e.dataSourceCollection && !e.dataSourceCollection.isDestroyed() && e.dataSourceCollection.remove(i);
  },
  provide(i) {
    return {
      entityCollection: i.entities,
      dataSource: i
    };
  },
  cesiumProps: ao,
  cesiumEventProps: co,
  useCommonEvent: !0
}), ls = lo, uo = [
  "heightReference",
  "length",
  "topRadius",
  "bottomRadius",
  "show",
  "fill",
  "material",
  "outline",
  "outlineColor",
  "outlineWidth",
  "numberOfVerticalLines",
  "slices",
  "distanceDisplayCondition",
  "shadows"
], mo = {
  onDefinitionChange: "definitionChanged"
}, ho = s({
  name: "CylinderGraphics",
  create(i, e) {
    if (!i.entity)
      return;
    const o = new Oe(e);
    return i.entity.cylinder = o, o;
  },
  destroy(i, e) {
    e.entity && (e.entity.cylinder = void 0);
  },
  cesiumProps: uo,
  cesiumEventProps: mo
}), ds = ho, yo = ["clustering", "show"], po = ["name", "sourceUri", "credit"], fo = {
  onChange: "changedEvent",
  onError: "errorEvent",
  onLoading: "loadingEvent"
}, go = ["onLoad", "data"], de = (i, { data: e, onLoad: o, ...t }) => {
  !e || i.load(e, t).then((n) => {
    o && o(n);
  });
}, Co = s({
  name: "CzmlDataSource",
  create(i, e) {
    if (!i.dataSourceCollection)
      return;
    const o = new Ae(e.name);
    return e.clustering && (o.clustering = e.clustering), typeof e.show == "boolean" && (o.show = e.show), i.dataSourceCollection.add(o), e.data && de(o, e), o;
  },
  update(i, e, o) {
    e.data ? o.show !== e.show && (i.show = typeof e.show == "boolean" ? e.show : !0) : i.show = !1, e.data && (o.data !== e.data || o.sourceUri !== e.sourceUri || o.credit !== e.credit) && de(i, e);
  },
  destroy(i, e) {
    e.dataSourceCollection && !e.dataSourceCollection.isDestroyed() && e.dataSourceCollection.remove(i);
  },
  provide(i) {
    return {
      dataSource: i
    };
  },
  cesiumProps: yo,
  cesiumReadonlyProps: po,
  cesiumEventProps: fo,
  otherProps: go,
  useCommonEvent: !0
}), us = Co, vo = [
  "semiMajorAxis",
  "semiMinorAxis",
  "height",
  "heightReference",
  "extrudedHeight",
  "show",
  "fill",
  "material",
  "outline",
  "outlineColor",
  "outlineWidth",
  "numberOfVerticalLines",
  "rotation",
  "stRotation",
  "granularity",
  "shadows",
  "distanceDisplayCondition",
  "zIndex",
  "classificationType",
  "extrudedHeightReference"
], Po = {
  onDefinitionChange: "definitionChanged"
}, So = s({
  name: "EllipseGraphics",
  create(i, e) {
    if (!i.entity)
      return;
    const o = new Fe(e);
    return i.entity.ellipse = o, o;
  },
  destroy(i, e) {
    e.entity && (e.entity.ellipse = void 0);
  },
  cesiumProps: vo,
  cesiumEventProps: Po
}), ms = So, wo = [
  "heightReference",
  "radii",
  "show",
  "fill",
  "innerRadii",
  "material",
  "maximumClock",
  "maximumCone",
  "minimumClock",
  "minimumCone",
  "outline",
  "outlineColor",
  "outlineWidth",
  "subdivisions",
  "stackPartitions",
  "slicePartitions",
  "shadows",
  "distanceDisplayCondition"
], Eo = {
  onDefinitionChange: "definitionChanged"
}, bo = s({
  name: "EllipsoidGraphics",
  create(i, e) {
    if (!i.entity)
      return;
    const o = new Ie(e);
    return i.entity.ellipsoid = o, o;
  },
  destroy(i, e) {
    e.entity && (e.entity.ellipsoid = void 0);
  },
  cesiumProps: wo,
  cesiumEventProps: Eo
}), hs = bo, Do = [
  "availability",
  "billboard",
  "box",
  "corridor",
  "cylinder",
  "description",
  "ellipse",
  "ellipsoid",
  "entityCollection",
  "label",
  "model",
  "name",
  "orientation",
  "path",
  "plane",
  "parent",
  "point",
  "polygon",
  "polyline",
  "polylineVolume",
  "position",
  "properties",
  "rectangle",
  "show",
  "tileset",
  "viewFrom",
  "wall"
], $o = ["id"], Mo = {
  onDefinitionChange: "definitionChanged"
}, Ro = ["selected", "tracked"], Go = s({
  name: "Entity",
  create(i, e) {
    if (!i.entityCollection)
      return;
    const o = new Ve(e);
    return i.viewer && e.selected && (i.viewer.selectedEntity = o), i.viewer && e.tracked && (i.viewer.trackedEntity = o), i.entityCollection.add(o), o;
  },
  destroy(i, e) {
    e.entityCollection && e.entityCollection.remove(i);
  },
  update(i, e, o, t) {
    t.viewer && (e.selected !== o.selected && (e.selected ? t.viewer.selectedEntity = i : t.viewer.selectedEntity === i && (t.viewer.selectedEntity = void 0)), e.tracked !== o.tracked && (e.tracked ? t.viewer.trackedEntity = i : t.viewer.trackedEntity === i && (t.viewer.trackedEntity = void 0)));
  },
  provide(i) {
    return {
      entity: i
    };
  },
  cesiumProps: Do,
  cesiumReadonlyProps: $o,
  cesiumEventProps: Mo,
  otherProps: Ro,
  useCommonEvent: !0
}), ys = Go, To = ({
  children: i,
  container: e,
  resizeInfoBox: o = !0
}) => {
  const { viewer: t, entity: n } = z(), [r, u] = ye(!1), h = Ee(
    () => {
      var c;
      return e ?? ((c = t == null ? void 0 : t.infoBox.frame.contentDocument) == null ? void 0 : c.createElement("div"));
    },
    [e, t == null ? void 0 : t.infoBox.frame.contentDocument]
  );
  return L(() => {
    if (!t || !n)
      return;
    const c = (y) => {
      u(!!y && y.id === n.id);
    };
    return t.selectedEntityChanged.addEventListener(c), () => {
      t.selectedEntityChanged.removeEventListener(c);
    };
  }, [n, t]), L(() => {
    var g, w;
    if (e || !h || !t)
      return;
    const c = (g = t.infoBox) == null ? void 0 : g.frame, y = (w = c == null ? void 0 : c.contentDocument) == null ? void 0 : w.querySelector(".cesium-infoBox-description");
    if (!c || !y)
      return;
    let f;
    if (r) {
      if (o) {
        const a = y.getBoundingClientRect().height;
        c.style.height = a + "px", f = window.setTimeout(() => {
          var p;
          y.appendChild(h), (p = t.infoBox.container.querySelector(".cesium-infoBox.cesium-infoBox-bodyless")) == null || p.classList.remove("cesium-infoBox-bodyless"), c.style.height = y.getBoundingClientRect().height + "px";
        }, 10);
      }
    } else
      h.parentElement === y && y.removeChild(h);
    return f ? () => clearTimeout(f) : void 0;
  }, [h, e, o, r, t]), h ? di(!e || r ? i : null, h) : null;
}, ps = To, ko = [
  "density",
  "enabled",
  "minimumBrightness",
  "screenSpaceErrorFactor",
  "renderable"
], Lo = s({
  name: "Fog",
  create(i) {
    if (!i.scene)
      return;
    const e = new ae();
    return i.scene.fog = e, e;
  },
  destroy(i, e) {
    e.scene && !e.scene.isDestroyed() && (e.scene.fog = new ae());
  },
  cesiumProps: ko,
  setCesiumPropsAfterCreate: !0
}), fs = Lo, Bo = ["clustering", "name", "show"], Oo = [
  "clampToGround",
  "sourceUri",
  "credit",
  "markerSize",
  "markerSymbol",
  "markerColor",
  "stroke",
  "strokeWidth",
  "fill",
  "describe"
], Ao = {
  onChange: "changedEvent",
  onError: "errorEvent",
  onLoading: "loadingEvent"
}, Fo = ["onLoad", "data"], ue = (i, { data: e, onLoad: o, ...t }) => {
  !e || i.load(e, t).then((n) => {
    o && o(n);
  });
}, Io = s({
  name: "GeoJsonDataSource",
  create(i, e) {
    if (!i.dataSourceCollection)
      return;
    const o = new _e(e.name);
    return e.clustering && (o.clustering = e.clustering), typeof e.show == "boolean" && (o.show = e.show), i.dataSourceCollection.add(o), e.data && ue(o, e), o;
  },
  update(i, e, o) {
    e.data ? o.show !== e.show && (i.show = typeof e.show == "boolean" ? e.show : !0) : i.show = !1, e.data && (o.data !== e.data || o.clampToGround !== e.clampToGround || o.sourceUri !== e.sourceUri || o.credit !== e.credit || o.markerSize !== e.markerSize || o.markerSymbol !== e.markerSymbol || o.markerColor !== e.markerColor || o.stroke !== e.stroke || o.strokeWidth !== e.strokeWidth || o.fill !== e.fill) && ue(i, e);
  },
  destroy(i, e) {
    e.dataSourceCollection && !e.dataSourceCollection.isDestroyed() && e.dataSourceCollection.remove(i);
  },
  provide(i) {
    return {
      dataSource: i
    };
  },
  cesiumProps: Bo,
  cesiumReadonlyProps: Oo,
  cesiumEventProps: Ao,
  otherProps: Fo,
  useCommonEvent: !0
}), gs = Io, Vo = {
  onImageryLayersUpdate: "imageryLayersUpdatedEvent",
  onTerrainProviderChange: "terrainProviderChanged",
  onTileLoadProgress: "tileLoadProgressEvent"
}, _o = [
  "atmosphereBrightnessShift",
  "atmosphereHueShift",
  "atmosphereSaturationShift",
  "backFaceCulling",
  "baseColor",
  "clippingPlanes",
  "depthTestAgainstTerrain",
  "enableLighting",
  "lightingFadeInDistance",
  "lightingFadeOutDistance",
  "material",
  "maximumScreenSpaceError",
  "nightFadeInDistance",
  "nightFadeOutDistance",
  "oceanNormalMapUrl",
  "shadows",
  "show",
  "showGroundAtmosphere",
  "showWaterEffect",
  "terrainProvider",
  "tileCacheSize",
  "loadingDescendantLimit",
  "preloadAncestors",
  "preloadSiblings",
  "fillHighlightColor",
  "dynamicAtmosphereLighting",
  "dynamicAtmosphereLightingFromSun",
  "showSkirts",
  "cartographicLimitRectangle",
  "translucency",
  "undergroundColor",
  "undergroundColorAlphaByDistance",
  "terrainExaggeration",
  "terrainExaggerationRelativeHeight",
  "lambertDiffuseMultiplier",
  "atmosphereLightIntensity",
  "atmosphereRayleighCoefficient",
  "atmosphereMieCoefficient",
  "atmosphereRayleighScaleHeight",
  "atmosphereMieScaleHeight",
  "atmosphereMieAnisotropy"
], Uo = s({
  name: "Globe",
  create: (i) => {
    var e;
    return (e = i.scene) == null ? void 0 : e.globe;
  },
  cesiumProps: _o,
  cesiumEventProps: Vo,
  setCesiumPropsAfterCreate: !0
}), Cs = Uo, Wo = [
  "appearance",
  "classificationType",
  "debugShowBoundingVolume",
  "debugShowShadowVolume",
  "show"
], Ho = [
  "allowPicking",
  "asynchronous",
  "geometryInstances",
  "interleave",
  "releaseGeometryInstances"
], zo = ["onReady"], No = s({
  name: "GroundPolylinePrimitive",
  create(i, e) {
    if (!i.primitiveCollection)
      return;
    const o = new Ue(e);
    return e.onReady && o.readyPromise.then(e.onReady), i.primitiveCollection.add(o), o;
  },
  destroy(i, e) {
    e.primitiveCollection && !e.primitiveCollection.isDestroyed() && e.primitiveCollection.remove(i), i.isDestroyed() || i.destroy();
  },
  cesiumProps: Wo,
  cesiumReadonlyProps: Ho,
  otherProps: zo,
  useCommonEvent: !0
}), vs = No, Ko = [
  "appearance",
  "classificationType",
  "debugShowBoundingVolume",
  "debugShowShadowVolume",
  "show"
], jo = [
  "allowPicking",
  "asynchronous",
  "compressVertices",
  "geometryInstances",
  "interleave",
  "releaseGeometryInstances",
  "vertexCacheOptimize"
], qo = ["onReady"], Jo = s({
  name: "GroundPrimitive",
  create(i, e) {
    if (!i.primitiveCollection)
      return;
    const o = new We(e);
    return e.onReady && o.readyPromise.then(e.onReady), i.primitiveCollection.add(o), o;
  },
  destroy(i, e) {
    e.primitiveCollection && !e.primitiveCollection.isDestroyed() && e.primitiveCollection.remove(i), i.isDestroyed() || i.destroy();
  },
  cesiumProps: Ko,
  cesiumReadonlyProps: jo,
  otherProps: qo,
  useCommonEvent: !0
}), Ps = Jo, Zo = ["show", "destroyPrimitives"], Qo = s({
  name: "GroundPrimitiveCollection",
  create: (i) => {
    var e;
    return (e = i.scene) == null ? void 0 : e.groundPrimitives;
  },
  provide: (i) => ({
    primitiveCollection: i
  }),
  cesiumProps: Zo,
  setCesiumPropsAfterCreate: !0
}), Ss = Qo, xo = [
  "alpha",
  "brightness",
  "contrast",
  "hue",
  "saturation",
  "gamma",
  "splitDirection",
  "minificationFilter",
  "magnificationFilter",
  "cutoutRectangle",
  "show",
  "nightAlpha",
  "dayAlpha",
  "colorToAlpha",
  "colorToAlphaThreshold"
], Xo = [
  "imageryProvider",
  "rectangle",
  "maximumAnisotropy",
  "minimumTerrainLevel",
  "maximumTerrainLevel"
], Yo = s({
  name: "ImageryLayer",
  create(i, e) {
    if (!i.imageryLayerCollection)
      return;
    const o = new He(e.imageryProvider, e);
    return i.imageryLayerCollection.add(o), o;
  },
  destroy(i, e) {
    e.imageryLayerCollection && e.imageryLayerCollection.remove(i);
  },
  cesiumProps: xo,
  cesiumReadonlyProps: Xo
}), ws = Yo, et = {
  onLayerAdd: "layerAdded",
  onLayerMove: "layerMoved",
  onLayerRemove: "layerRemoved",
  onLayerShowOrHide: "layerShownOrHidden"
}, it = s({
  name: "ImageryLayerCollection",
  create: (i) => {
    var e;
    return (e = i.globe) == null ? void 0 : e.imageryLayers;
  },
  cesiumEventProps: et
}), Es = it, ot = ["clustering", "name", "show"], tt = [
  "canvas",
  "camera",
  "ellipsoid",
  "clampToGround",
  "sourceUri",
  "credit",
  "screenOverlayContainer"
], nt = {
  onChange: "changedEvent",
  onError: "errorEvent",
  onLoading: "loadingEvent",
  onRefresh: "refreshEvent",
  onUnsupportedNode: "unsupportedNodeEvent"
}, st = ["onLoad", "data"], me = (i, { data: e, onLoad: o, ...t }) => {
  !e || i.load(e, t).then((n) => {
    o && o(n);
  });
}, rt = s({
  name: "KmlDataSource",
  create(i, e) {
    if (!i.scene || !i.dataSourceCollection || !i.scene)
      return;
    const o = new ze({
      camera: e.camera || i.scene.camera,
      canvas: e.canvas || i.scene.canvas,
      ellipsoid: e.ellipsoid,
      credit: e.credit
    });
    return e.clustering && (o.clustering = e.clustering), typeof e.show == "boolean" && (o.show = e.show), typeof e.name < "u" && (o.name = e.name), i.dataSourceCollection.add(o), e.data && me(o, e), o;
  },
  update(i, e, o) {
    e.data ? o.show !== e.show && (i.show = typeof e.show == "boolean" ? e.show : !0) : i.show = !1, e.data && (o.data !== e.data || o.clampToGround !== e.clampToGround || o.ellipsoid !== e.ellipsoid || o.sourceUri !== e.sourceUri || o.credit !== e.credit) && me(i, e);
  },
  destroy(i, e) {
    e.dataSourceCollection && !e.dataSourceCollection.isDestroyed() && e.dataSourceCollection.remove(i);
  },
  provide(i) {
    return {
      dataSource: i
    };
  },
  cesiumProps: ot,
  cesiumReadonlyProps: tt,
  cesiumEventProps: nt,
  otherProps: st,
  useCommonEvent: !0
}), bs = rt, at = [
  "backgroundColor",
  "backgroundPadding",
  "disableDepthTestDistance",
  "distanceDisplayCondition",
  "eyeOffset",
  "fillColor",
  "font",
  "heightReference",
  "horizontalOrigin",
  "outlineColor",
  "outlineWidth",
  "pixelOffset",
  "pixelOffsetScaleByDistance",
  "position",
  "scale",
  "scaleByDistance",
  "show",
  "showBackground",
  "style",
  "text",
  "translucencyByDistance",
  "verticalOrigin"
], ct = s({
  name: "Label",
  create: (i, e) => {
    var o;
    return (o = i.labelCollection) == null ? void 0 : o.add(e);
  },
  destroy(i, e) {
    e.labelCollection && !e.labelCollection.isDestroyed() && e.labelCollection.remove(i);
  },
  cesiumProps: at,
  useCommonEvent: !0
}), Ds = ct, lt = ["blendOption", "debugShowBoundingVolume", "modelMatrix", "show"], dt = s({
  name: "LabelCollection",
  create(i, e) {
    if (!i.scene || !i.primitiveCollection)
      return;
    const o = new Ne({
      scene: i.scene,
      modelMatrix: e.modelMatrix,
      blendOption: e.blendOption,
      debugShowBoundingVolume: e.debugShowBoundingVolume
    });
    return i.primitiveCollection.add(o), o;
  },
  destroy(i, e) {
    e.primitiveCollection && !e.primitiveCollection.isDestroyed() && e.primitiveCollection.remove(i), i.isDestroyed() || i.destroy();
  },
  provide(i) {
    return {
      labelCollection: i
    };
  },
  cesiumProps: lt
}), $s = dt, ut = [
  "text",
  "font",
  "style",
  "fillColor",
  "outlineColor",
  "outlineWidth",
  "show",
  "showBackground",
  "backgroundColor",
  "backgroundPadding",
  "scale",
  "horizontalOrigin",
  "verticalOrigin",
  "eyeOffset",
  "pixelOffset",
  "translucencyByDistance",
  "pixelOffsetScaleByDistance",
  "scaleByDistance",
  "heightReference",
  "distanceDisplayCondition",
  "disableDepthTestDistance"
], mt = {
  onDefinitionChange: "definitionChanged"
}, ht = s({
  name: "LabelGraphics",
  create(i, e) {
    if (!i.entity)
      return;
    const o = new Ke(e);
    return i.entity.label = o, o;
  },
  destroy(i, e) {
    e.entity && (e.entity.label = void 0);
  },
  cesiumProps: ut,
  cesiumEventProps: mt
}), Ms = ht, yt = [
  "backFaceCulling",
  "clampAnimations",
  "clippingPlanes",
  "color",
  "colorBlendAmount",
  "colorBlendMode",
  "customShader",
  "debugShowBoundingVolume",
  "debugWireframe",
  "distanceDisplayCondition",
  "featureIdLabel",
  "heightReference",
  "id",
  "imageBasedLighting",
  "instanceFeatureIdLabel",
  "lightColor",
  "maximumScale",
  "minimumPixelSize",
  "modelMatrix",
  "outlineColor",
  "scale",
  "shadows",
  "show",
  "showCreditsOnScreen",
  "showOutline",
  "silhouetteColor",
  "silhouetteSize",
  "splitDirection",
  "style"
], pt = [
  "allowPicking",
  "asynchronous",
  "basePath",
  "credit",
  "enableDebugWireframe",
  "gltf",
  "heightReference",
  "incrementallyLoadTextures",
  "scene",
  "url",
  "releaseGltfJson",
  "cull",
  "opaquePass",
  "upAxis",
  "forwardAxis",
  "content",
  "scene",
  "enableShowOutline",
  "projectTo2D",
  "classificationType"
], ft = ["onReady"], gt = s({
  name: "Model",
  create(i, { scene: e, url: o, colorBlendMode: t, ...n }) {
    if (!i.scene || !i.primitiveCollection || !o)
      return;
    const r = je.fromGltf({
      ...n,
      url: o,
      colorBlendMode: t,
      scene: e || i.scene
    });
    return n.onReady && r.readyPromise.then(n.onReady), i.primitiveCollection.add(r), r;
  },
  destroy(i, e) {
    e.primitiveCollection && !e.primitiveCollection.isDestroyed() && e.primitiveCollection.remove(i), i.isDestroyed() || i.destroy();
  },
  cesiumProps: yt,
  cesiumReadonlyProps: pt,
  otherProps: ft,
  useCommonEvent: !0
}), Rs = gt, Ct = [
  "uri",
  "show",
  "scale",
  "minimumPixelSize",
  "maximumScale",
  "incrementallyLoadTextures",
  "runAnimations",
  "clampAnimations",
  "nodeTransformations",
  "shadows",
  "heightReference",
  "distanceDisplayCondition",
  "silhouetteColor",
  "silhouetteSize",
  "color",
  "colorBlendMode",
  "colorBlendAmount",
  "clippingPlanes",
  "imageBasedLightingFactor",
  "lightColor",
  "articulations",
  "customShader"
], vt = {
  onDefinitionChange: "definitionChanged"
}, Pt = s({
  name: "ModelGraphics",
  create(i, e) {
    if (!i.entity)
      return;
    const o = new qe(e);
    return i.entity.model = o, o;
  },
  destroy(i, e) {
    e.entity && (e.entity.model = void 0);
  },
  cesiumProps: Ct,
  cesiumEventProps: vt
}), Gs = Pt, St = ["onlySunLighting", "show", "textureUrl"], wt = ["ellipsoid"], Et = s({
  name: "Moon",
  create(i, e) {
    if (!i.scene)
      return;
    const o = new ce(e);
    return i.scene.moon = o, o;
  },
  destroy(i, e) {
    e.scene && !e.scene.isDestroyed() && (e.scene.moon = new ce());
  },
  cesiumProps: St,
  cesiumReadonlyProps: wt
}), Ts = Et, bt = [
  "show",
  "emitter",
  "modelMatrix",
  "emitterModelMatrix",
  "emissionRate",
  "bursts",
  "loop",
  "startScale",
  "endScale",
  "startColor",
  "endColor",
  "image",
  "imageSize",
  "minimumImageSize",
  "maximumImageSize",
  "speed",
  "minimumSpeed",
  "maximumSpeed",
  "lifetime",
  "particleLife",
  "minimumParticleLife",
  "maximumParticleLife",
  "mass",
  "minimumMass",
  "maximumMass",
  "sizeInMeters"
], Dt = {
  onComplete: "complete",
  onUpdate: "updateCallback"
}, $t = s({
  name: "ParticleSystem",
  create(i, e) {
    if (!i.primitiveCollection)
      return;
    const o = new Je({ ...e, updateCallback: e.onUpdate });
    return i.primitiveCollection.add(o), o;
  },
  update(i, e, o) {
    e.onUpdate !== o.onUpdate && (i.updateCallback = e.onUpdate);
  },
  destroy(i, e) {
    e.primitiveCollection && !e.primitiveCollection.isDestroyed() && e.primitiveCollection.remove(i);
  },
  cesiumProps: bt,
  cesiumEventProps: Dt
}), ks = $t, Mt = [
  "leadTime",
  "trailTime",
  "show",
  "width",
  "material",
  "resolution",
  "distanceDisplayCondition"
], Rt = {
  onDefinitionChange: "definitionChanged"
}, Gt = s({
  name: "PathGraphics",
  create(i, e) {
    if (!i.entity)
      return;
    const o = new Ze(e);
    return i.entity.path = o, o;
  },
  destroy(i, e) {
    e.entity && (e.entity.path = void 0);
  },
  cesiumProps: Mt,
  cesiumEventProps: Rt
}), Ls = Gt, Tt = [
  "plane",
  "dimensions",
  "show",
  "fill",
  "material",
  "outline",
  "outlineColor",
  "outlineWidth",
  "shadows",
  "distanceDisplayCondition"
], kt = {
  onDefinitionChange: "definitionChanged"
}, Lt = s({
  name: "PlaneGraphics",
  create(i, e) {
    if (!i.entity)
      return;
    const o = new Qe(e);
    return i.entity.plane = o, o;
  },
  destroy(i, e) {
    e.entity && (e.entity.plane = void 0);
  },
  cesiumProps: Tt,
  cesiumEventProps: kt
}), Bs = Lt, Bt = [
  "color",
  "pixelSize",
  "outlineColor",
  "outlineWidth",
  "show",
  "scaleByDistance",
  "translucencyByDistance",
  "heightReference",
  "distanceDisplayCondition",
  "disableDepthTestDistance"
], Ot = {
  onDefinitionChange: "definitionChanged"
}, At = s({
  name: "PointGraphics",
  create(i, e) {
    if (!i.entity)
      return;
    const o = new xe(e);
    return i.entity.point = o, o;
  },
  destroy(i, e) {
    e.entity && (e.entity.point = void 0);
  },
  cesiumProps: Bt,
  cesiumEventProps: Ot
}), Os = At, Ft = [
  "color",
  "disableDepthTestDistance",
  "distanceDisplayCondition",
  "id",
  "outlineColor",
  "outlineWidth",
  "pixelSize",
  "position",
  "scaleByDistance",
  "show",
  "translucencyByDistance"
], It = s({
  name: "PointPrimitive",
  create: (i, e) => {
    var o;
    return (o = i.pointPrimitiveCollection) == null ? void 0 : o.add(e);
  },
  destroy(i, e) {
    e.pointPrimitiveCollection && !e.pointPrimitiveCollection.isDestroyed() && e.pointPrimitiveCollection.remove(i);
  },
  cesiumProps: Ft,
  useCommonEvent: !0
}), As = It, Vt = ["blendOption", "debugShowBoundingVolume", "modelMatrix", "show"], _t = s({
  name: "PointPrimitveCollection",
  create(i, e) {
    if (!i.primitiveCollection)
      return;
    const o = new Xe(e);
    return i.primitiveCollection.add(o), o;
  },
  destroy(i, e) {
    e.primitiveCollection && !e.primitiveCollection.isDestroyed() && e.primitiveCollection.remove(i), i.isDestroyed() || i.destroy();
  },
  provide(i) {
    return {
      pointPrimitiveCollection: i
    };
  },
  cesiumProps: Vt
}), Fs = _t, Ut = [
  "arcType",
  "hierarchy",
  "height",
  "heightReference",
  "extrudedHeight",
  "extrudedHeightReference",
  "show",
  "fill",
  "material",
  "outline",
  "outlineColor",
  "outlineWidth",
  "stRotation",
  "granularity",
  "perPositionHeight",
  "closeTop",
  "closeBottom",
  "shadows",
  "distanceDisplayCondition",
  "zIndex",
  "classificationType",
  "textureCoordinates"
], Wt = {
  onDefinitionChange: "definitionChanged"
}, Ht = s({
  name: "PolygonGraphics",
  create(i, e) {
    if (!i.entity)
      return;
    const o = new Ye(e);
    return i.entity.polygon = o, o;
  },
  destroy(i, e) {
    e.entity && (e.entity.polygon = void 0);
  },
  cesiumProps: Ut,
  cesiumEventProps: Wt
}), Is = Ht, zt = [
  "distanceDisplayCondition",
  "id",
  "loop",
  "material",
  "positions",
  "show",
  "width"
], Nt = s({
  name: "Polyline",
  create: (i, e) => {
    var o;
    return (o = i.polylineCollection) == null ? void 0 : o.add(e);
  },
  destroy(i, e) {
    e.polylineCollection && !e.polylineCollection.isDestroyed() && e.polylineCollection.remove(i);
  },
  cesiumProps: zt,
  useCommonEvent: !0
}), Vs = Nt, Kt = ["debugShowBoundingVolume", "length", "modelMatrix", "show"], jt = s(
  {
    name: "PolylineCollection",
    create(i, e) {
      if (!i.primitiveCollection)
        return;
      const o = new ei({
        modelMatrix: e.modelMatrix,
        debugShowBoundingVolume: e.debugShowBoundingVolume,
        length: e.length,
        scene: i.scene
      });
      return i.primitiveCollection.add(o), o;
    },
    destroy(i, e) {
      e.primitiveCollection && !e.primitiveCollection.isDestroyed() && e.primitiveCollection.remove(i), i.isDestroyed() || i.destroy();
    },
    provide(i) {
      return {
        polylineCollection: i
      };
    },
    cesiumProps: Kt
  }
), _s = jt, qt = [
  "arcType",
  "classificationType",
  "positions",
  "clampToGround",
  "width",
  "show",
  "material",
  "depthFailMaterial",
  "granularity",
  "shadows",
  "distanceDisplayCondition",
  "zIndex"
], Jt = {
  onDefinitionChange: "definitionChanged"
}, Zt = s({
  name: "PolylineGraphics",
  create(i, e) {
    if (!i.entity)
      return;
    const o = new ii(e);
    return i.entity.polyline = o, o;
  },
  destroy(i, e) {
    e.entity && (e.entity.polyline = void 0);
  },
  cesiumProps: qt,
  cesiumEventProps: Jt
}), Us = Zt, Qt = [
  "positions",
  "shape",
  "cornerType",
  "show",
  "fill",
  "material",
  "outline",
  "outlineColor",
  "outlineWidth",
  "granularity",
  "shadows",
  "distanceDisplayCondition"
], xt = {
  onDefinitionChange: "definitionChanged"
}, Xt = s({
  name: "PolylineVolumeGraphics",
  create(i, e) {
    if (!i.entity)
      return;
    const o = new oi(e);
    return i.entity.polylineVolume = o, o;
  },
  destroy(i, e) {
    e.entity && (e.entity.polylineVolume = void 0);
  },
  cesiumProps: Qt,
  cesiumEventProps: xt
}), Ws = Xt, Yt = ["enabled", "selected"], en = [
  "clearColor",
  "forcePowerOfTwo",
  "fragmentShader",
  "name",
  "pixelDatatype",
  "pixelFormat",
  "sampleMode",
  "scissorRectangle",
  "textureScale",
  "uniforms"
], Hs = s({
  name: "PostProcessStage",
  create(i, e) {
    if (!i.scene)
      return;
    const o = new ti(e);
    return typeof e.enabled == "boolean" && (o.enabled = e.enabled), e.selected && (o.selected = e.selected), i.scene.postProcessStages.add(o), o;
  },
  destroy(i, e) {
    e.scene && !e.scene.isDestroyed() && e.scene.postProcessStages.remove(i), i.isDestroyed() || i.destroy();
  },
  cesiumProps: Yt,
  cesiumReadonlyProps: en
}), zs = P({
  name: "BlackAndWhiteStage",
  props: ["gradations"],
  create: () => M.createBlackAndWhiteStage()
}), Ns = P({
  name: "BrightnessStage",
  props: ["brightness"],
  create: () => M.createBrightnessStage()
}), Ks = P({
  name: "LensFlareStage",
  props: [
    "dirtTexture",
    "starTexture",
    "intensity",
    "distortion",
    "ghostDispersal",
    "haloWidth",
    "earthRadius"
  ],
  create: () => M.createLensFlareStage()
}), js = P({
  name: "Fxaa",
  create: (i, e) => e.fxaa,
  props: []
}), qs = P({
  name: "NightVisionStage",
  props: [],
  create: () => M.createNightVisionStage()
}), on = ["enabled", "selected"], tn = ["inputPreviousStageTexture", "name", "stages", "uniforms"], Js = s({
  name: "PostProcessStageComposite",
  create(i, e) {
    if (!i.scene)
      return;
    const o = new ni(e);
    return typeof e.enabled == "boolean" && (o.enabled = e.enabled), e.selected && (o.selected = e.selected), i.scene.postProcessStages.add(o), o;
  },
  destroy(i, e) {
    e.scene && !e.scene.isDestroyed() && e.scene.postProcessStages.remove(i), i.isDestroyed() || i.destroy();
  },
  cesiumProps: on,
  cesiumReadonlyProps: tn
}), Zs = P({
  name: "AmbientOcclusion",
  create: (i, e) => e.ambientOcclusion,
  props: [
    "ambientOcclusionOnly",
    "bias",
    "delta",
    "frustumLength",
    "intensity",
    "lengthCap",
    "sigma",
    "stepSize"
  ],
  noMount: !0
}), Qs = P({
  name: "Bloom",
  create: (i, e) => e.bloom,
  props: ["brightness", "contrast", "delta", "glowOnly", "sigma", "stepSize"],
  noMount: !0
}), xs = P({
  name: "BlurStage",
  props: ["delta", "sigma", "stepSize"],
  create: () => M.createBlurStage()
}), Xs = P({
  name: "DepthOfFieldStage",
  props: ["delta", "focalDistance", "sigma", "stepSize"],
  create: () => M.createDepthOfFieldStage()
}), Ys = P({
  name: "EdgeDetectionStage",
  props: ["color", "length"],
  create: () => M.createEdgeDetectionStage()
}), er = P({
  name: "SilhouetteStage",
  props: ["color", "length"],
  create: () => M.createSilhouetteStage()
}), nn = [
  "appearance",
  "cull",
  "debugShowBoundingVolume",
  "depthFailAppearance",
  "modelMatrix",
  "shadows",
  "show"
], sn = [
  "allowPicking",
  "asynchronous",
  "compressVertices",
  "geometryInstances",
  "interleave",
  "releaseGeometryInstances",
  "vertexCacheOptimize"
], rn = ["onReady"], an = s({
  name: "Primitive",
  create(i, e) {
    if (!i.primitiveCollection)
      return;
    const o = new si(e);
    return e.onReady && o.readyPromise.then(e.onReady), i.primitiveCollection.add(o), o;
  },
  destroy(i, e) {
    e.primitiveCollection && !e.primitiveCollection.isDestroyed() && e.primitiveCollection.remove(i), i.isDestroyed() || i.destroy();
  },
  cesiumProps: nn,
  cesiumReadonlyProps: sn,
  otherProps: rn,
  useCommonEvent: !0
}), ir = an, cn = [
  "classificationType",
  "coordinates",
  "height",
  "heightReference",
  "extrudedHeight",
  "extrudedHeightReference",
  "show",
  "fill",
  "material",
  "outline",
  "outlineColor",
  "outlineWidth",
  "rotation",
  "stRotation",
  "granularity",
  "shadows",
  "distanceDisplayCondition",
  "zIndex"
], ln = {
  onDefinitionChange: "definitionChanged"
}, dn = s({
  name: "RectangleGraphics",
  create(i, e) {
    if (!i.entity)
      return;
    const o = new ri(e);
    return i.entity.rectangle = o, o;
  },
  destroy(i, e) {
    e.entity && (e.entity.rectangle = void 0);
  },
  cesiumProps: cn,
  cesiumEventProps: ln
}), or = dn, un = [
  "backgroundColor",
  "completeMorphOnUserInput",
  "debugCommandFilter",
  "debugShowCommands",
  "debugShowDepthFrustum",
  "debugShowFramesPerSecond",
  "debugShowFrustumPlanes",
  "debugShowFrustums",
  "eyeSeparation",
  "farToNearRatio",
  "focalLength",
  "fog",
  "gamma",
  "globe",
  "highDynamicRange",
  "invertClassification",
  "invertClassificationColor",
  "light",
  "logarithmicDepthBuffer",
  "logarithmicDepthFarToNearRatio",
  "maximumRenderTimeChange",
  "minimumDisableDepthTestDistance",
  "moon",
  "morphTime",
  "nearToFarDistance2D",
  "pickTranslucentDepth",
  "requestRenderMode",
  "rethrowRenderErrors",
  "shadowMap",
  "skyAtmosphere",
  "skyBox",
  "specularEnvironmentMaps",
  "sphericalHarmonicCoefficients",
  "sun",
  "sunBloom",
  "terrainProvider",
  "useDepthPicking",
  "useWebVR",
  "postProcessStages",
  "msaaSamples",
  "splitPosition",
  "debugCommandFilter"
], mn = {
  onMorphComplete: "morphComplete",
  onMorphStart: "morphStart",
  onPostRender: "postRender",
  onPreRender: "preRender",
  onPreUpdate: "preUpdate",
  onPostUpdate: "postUpdate",
  onRenderError: "renderError",
  onTerrainProviderChange: "terrainProviderChanged"
}, hn = ["mode", "morphDuration"], he = (i, e, o) => {
  switch (e) {
    case X.SCENE2D:
      i.morphTo2D(o);
      break;
    case X.COLUMBUS_VIEW:
      i.morphToColumbusView(o);
      break;
    case X.SCENE3D:
      i.morphTo3D(o);
      break;
  }
}, yn = s({
  name: "Scene",
  create(i, e) {
    return i.scene && e.mode && he(i.scene, e.mode, e.morphDuration), i.scene;
  },
  update(i, e, o) {
    e.mode !== o.mode && e.mode && he(i, e.mode, e.morphDuration);
  },
  cesiumProps: un,
  cesiumEventProps: mn,
  otherProps: hn,
  setCesiumPropsAfterCreate: !0
}), tr = yn, pn = [
  "bounceAnimationTime",
  "enableCollisionDetection",
  "enableInputs",
  "enableLook",
  "enableRotate",
  "enableTilt",
  "enableTranslate",
  "enableZoom",
  "inertiaSpin",
  "inertiaTranslate",
  "inertiaZoom",
  "lookEventTypes",
  "maximumMovementRatio",
  "maximumZoomDistance",
  "minimumCollisionTerrainHeight",
  "minimumPickingTerrainHeight",
  "minimumTrackBallHeight",
  "minimumZoomDistance",
  "rotateEventTypes",
  "tiltEventTypes",
  "translateEventTypes",
  "zoomEventTypes"
], fn = s({
  name: "ScreenSpaceCameraController",
  create: (i) => {
    var e;
    return (e = i.scene) == null ? void 0 : e.screenSpaceCameraController;
  },
  cesiumProps: pn,
  setCesiumPropsAfterCreate: !0
}), nr = fn, gn = ({ action: i, modifier: e, type: o }) => {
  const t = z();
  return L(() => {
    if (!(!t.screenSpaceEventHandler || t.screenSpaceEventHandler.isDestroyed())) {
      if (i)
        return t.screenSpaceEventHandler.setInputAction(i, o, e), () => {
          !t.screenSpaceEventHandler || t.screenSpaceEventHandler.isDestroyed() || t.screenSpaceEventHandler.removeInputAction(o, e);
        };
      t.screenSpaceEventHandler.removeInputAction(o, e);
    }
  }, [i, t.screenSpaceEventHandler, e, o]), null;
}, sr = gn, Cn = s({
  name: "ScreenSpaceEventHandler",
  create(i, e) {
    var o;
    return e.useDefault ? (o = i.cesiumWidget) == null ? void 0 : o.screenSpaceEventHandler : i.scene ? new fe(i.scene.canvas) : void 0;
  },
  destroy(i) {
    i.isDestroyed() || i.destroy();
  },
  provide(i) {
    return {
      screenSpaceEventHandler: i
    };
  }
}), rr = Cn, vn = [
  "darkness",
  "fadingEnabled",
  "maximumDistance",
  "enabled",
  "normalOffset",
  "softShadows",
  "size"
], Pn = s({
  name: "ShadowMap",
  create: (i) => {
    var e;
    return (e = i.scene) == null ? void 0 : e.shadowMap;
  },
  cesiumProps: vn
}), ar = Pn, Sn = [
  "brightnessShift",
  "hueShift",
  "saturationShift",
  "show",
  "perFragmentAtmosphere",
  "atmosphereLightIntensity",
  "atmosphereRayleighCoefficient",
  "atmosphereMieCoefficient",
  "atmosphereRayleighScaleHeight",
  "atmosphereMieScaleHeight",
  "atmosphereMieAnisotropy"
], wn = s({
  name: "SkyAtmosphere",
  create: (i) => {
    var e;
    return (e = i.scene) == null ? void 0 : e.skyAtmosphere;
  },
  cesiumProps: Sn,
  setCesiumPropsAfterCreate: !0
}), cr = wn, En = ["sources", "show"], bn = s({
  name: "SkyBox",
  create: (i) => {
    var e;
    return (e = i.scene) == null ? void 0 : e.skyBox;
  },
  cesiumProps: En,
  setCesiumPropsAfterCreate: !0
}), lr = bn, Dn = ["glowFactor", "show"], $n = s({
  name: "Sun",
  create(i) {
    if (!i.scene)
      return;
    const e = new le();
    return i.scene.sun = e, e;
  },
  destroy(i, e) {
    e.scene && !e.scene.isDestroyed() && (e.scene.sun = new le());
  },
  cesiumProps: Dn,
  setCesiumPropsAfterCreate: !0
}), dr = $n, Mn = [
  "clippingPlanes",
  "maximumMemoryUsage",
  "modelMatrix",
  "shadows",
  "show",
  "style",
  "intervals"
], Rn = ["clock", "shading"], Gn = ["onReady"], Tn = {
  onFrameChange: "frameChanged"
}, kn = s({
  name: "TimeDynamicPointCloud",
  create(i, e) {
    var t;
    if (!i.cesiumWidget || !i.primitiveCollection || !((t = i.cesiumWidget) != null && t.clock))
      return;
    const o = new ai({
      ...e,
      clock: e.clock ?? i.cesiumWidget.clock
    });
    return e.onReady && o.readyPromise.then(e.onReady), i.primitiveCollection.add(o), o;
  },
  destroy(i, e) {
    e.primitiveCollection && !e.primitiveCollection.isDestroyed() && e.primitiveCollection.remove(i), i.isDestroyed() || i.destroy();
  },
  cesiumProps: Mn,
  cesiumReadonlyProps: Rn,
  cesiumEventProps: Tn,
  otherProps: Gn,
  useCommonEvent: !0
}), ur = kn, Ln = [
  "terrainProvider",
  "terrainShadows",
  "clockTrackedDataSource",
  "targetFrameRate",
  "useDefaultRenderLoop",
  "resolutionScale",
  "allowDataSourcesToSuspendAnimation",
  "trackedEntity",
  "selectedEntity",
  "shadows",
  "useBrowserRecommendedResolution"
], Bn = [
  "animation",
  "baseLayerPicker",
  "fullscreenButton",
  "vrButton",
  "geocoder",
  "homeButton",
  "infoBox",
  "sceneModePicker",
  "selectionIndicator",
  "timeline",
  "navigationHelpButton",
  "navigationInstructionsInitiallyVisible",
  "scene3DOnly",
  "shouldAnimate",
  "clockViewModel",
  "selectedImageryProviderViewModel",
  "imageryProviderViewModels",
  "selectedTerrainProviderViewModel",
  "terrainProviderViewModels",
  "imageryProvider",
  "skyBox",
  "skyAtmosphere",
  "fullscreenElement",
  "showRenderLoopErrors",
  "automaticallyTrackDataSourceClocks",
  "contextOptions",
  "sceneMode",
  "mapProjection",
  "globe",
  "orderIndependentTranslucency",
  "creditContainer",
  "creditViewport",
  "dataSources",
  "mapMode2D",
  "projectionPicker",
  "requestRenderMode",
  "maximumRenderTimeChange",
  "depthPlaneEllipsoidOffset",
  "msaaSamples",
  "blurActiveElementOnCanvasFocus"
], On = {
  onSelectedEntityChange: "selectedEntityChanged",
  onTrackedEntityChange: "trackedEntityChanged"
}, An = ["className", "id", "style", "full", "containerProps", "extend"], Fn = s({
  name: "Viewer",
  create(i, { imageryProvider: e, ...o }, t) {
    if (!t)
      return;
    const n = new ci(t, {
      ...o,
      imageryProvider: e === !1 ? void 0 : e
    });
    if (!n)
      return;
    e === !1 && n.imageryLayers.removeAll(), n && o.extend && (Array.isArray(o.extend) ? o.extend.forEach((u) => {
      n.extend(u, {});
    }) : n.extend(o.extend, {}));
    const r = new _(n.scene);
    return [n, r];
  },
  destroy(i, e, o, t) {
    t && !t.isDestroyed() && t.destroy(), i.isDestroyed() || i.destroy();
  },
  provide(i, e, o, t) {
    return {
      viewer: i,
      cesiumWidget: i.cesiumWidget,
      dataSourceCollection: i.dataSources,
      entityCollection: i.entities,
      scene: i.scene,
      camera: i.scene.camera,
      imageryLayerCollection: i.scene.globe.imageryLayers,
      primitiveCollection: i.scene.primitives,
      globe: i.scene.globe,
      __$internal: {
        onUpdate: o == null ? void 0 : o.onUpdate
      },
      [k]: t
    };
  },
  containerProps: ({ id: i, className: e, style: o, full: t, containerProps: n }) => ({
    className: e,
    id: i,
    style: {
      ...t ? {
        position: "absolute",
        bottom: "0",
        left: "0",
        right: "0",
        top: "0"
      } : {},
      ...o
    },
    ...n
  }),
  cesiumProps: Ln,
  cesiumReadonlyProps: Bn,
  cesiumEventProps: On,
  otherProps: An,
  renderContainer: !0,
  useCommonEvent: !0,
  useRootEvent: !0
}), mr = Fn, In = [
  "positions",
  "maximumHeights",
  "minimumHeights",
  "show",
  "fill",
  "material",
  "outline",
  "outlineColor",
  "outlineWidth",
  "granularity",
  "shadows",
  "distanceDisplayCondition"
], Vn = {
  onDefinitionChange: "definitionChanged"
}, _n = s({
  name: "WallGraphics",
  create(i, e) {
    if (!i.entity)
      return;
    const o = new li(e);
    return i.entity.wall = o, o;
  },
  destroy(i, e) {
    e.entity && (e.entity.wall = void 0);
  },
  cesiumProps: In,
  cesiumEventProps: Vn
}), hr = _n;
export {
  Zs as AmbientOcclusion,
  jn as Billboard,
  qn as BillboardCollection,
  Jn as BillboardGraphics,
  zs as BlackAndWhiteStage,
  Qs as Bloom,
  xs as BlurStage,
  Zn as BoxGraphics,
  Ns as BrightnessStage,
  Qn as Camera,
  xn as CameraFlyHome,
  Xn as CameraFlyTo,
  es as CameraFlyToBoundingSphere,
  Yn as CameraLookAt,
  is as Cesium3DTileset,
  os as Cesium3DTilesetGraphics,
  ie as CesiumContext,
  ts as CesiumWidget,
  ns as ClassificationPrimitive,
  ss as Clock,
  rs as CloudCollection,
  ui as Consumer,
  as as CorridorGraphics,
  cs as CumulusCloud,
  ls as CustomDataSource,
  ds as CylinderGraphics,
  us as CzmlDataSource,
  Xs as DepthOfFieldStage,
  Ys as EdgeDetectionStage,
  ms as EllipseGraphics,
  hs as EllipsoidGraphics,
  ys as Entity,
  ps as EntityDescription,
  _ as EventManager,
  fs as Fog,
  js as Fxaa,
  gs as GeoJsonDataSource,
  Cs as Globe,
  vs as GroundPolylinePrimitive,
  Ps as GroundPrimitive,
  Ss as GroundPrimitiveCollection,
  ws as ImageryLayer,
  Es as ImageryLayerCollection,
  bs as KmlDataSource,
  Ds as Label,
  $s as LabelCollection,
  Ms as LabelGraphics,
  Ks as LensFlareStage,
  Rs as Model,
  Gs as ModelGraphics,
  Ts as Moon,
  qs as NightVisionStage,
  ks as ParticleSystem,
  Ls as PathGraphics,
  Bs as PlaneGraphics,
  Os as PointGraphics,
  As as PointPrimitive,
  Fs as PointPrimitiveCollection,
  Is as PolygonGraphics,
  Vs as Polyline,
  _s as PolylineCollection,
  Us as PolylineGraphics,
  Ws as PolylineVolumeGraphics,
  Hs as PostProcessStage,
  Js as PostProcessStageComposite,
  ir as Primitive,
  Nn as Provider,
  or as RectangleGraphics,
  tr as Scene,
  nr as ScreenSpaceCameraController,
  sr as ScreenSpaceEvent,
  rr as ScreenSpaceEventHandler,
  ar as ShadowMap,
  er as SilhouetteStage,
  cr as SkyAtmosphere,
  lr as SkyBox,
  dr as Sun,
  ur as TimeDynamicPointCloud,
  mr as Viewer,
  hr as WallGraphics,
  N as createCameraOperation,
  s as createCesiumComponent,
  P as createPostProcessStage,
  Y as entries,
  k as eventManagerContextKey,
  ee as eventNames,
  U as includes,
  yi as isDestroyable,
  pi as isDestroyed,
  mi as pick,
  hi as shallowEquals,
  z as useCesium,
  fi as useCesiumComponent,
  Kn as withCesium
};
